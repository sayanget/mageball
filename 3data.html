<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>欧拉公式彩票数据可视化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            overflow: hidden;
        }
        canvas {
            display: block;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            touch-action: none; /* Prevent default touch actions on mobile */
        }
        .container {
            max-width: 900px;
            width: 100%;
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        h1 {
            font-size: 2rem;
            font-weight: bold;
            color: #4fd1c5;
            margin-bottom: 1rem;
        }
        p {
            font-size: 1rem;
            color: #cbd5e0;
            margin-bottom: 1rem;
        }
        .info-box {
            background-color: #4a5568;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            text-align: left;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4fd1c5;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #canvas-container {
            height: 500px; /* Enforce a fixed height */
            width: 100%;
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .controls label {
            white-space: nowrap;
        }
        .controls input[type="date"] {
            padding: 0.5rem;
            border-radius: 8px;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
        }
        .controls button {
            background-color: #4fd1c5;
            color: #1a202c;
            font-weight: bold;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .controls button:hover {
            background-color: #38b2ac;
        }
    </style>
</head>
<body>
    <div class="container rounded-2xl shadow-lg">
        <h1>欧拉公式彩票数据可视化</h1>
        <p>通过手动设置时间区间，将彩票号码代入欧拉公式并进行三维可视化。</p>
        
        <div class="controls">
            <label for="start-date">开始日期:</label>
            <input type="date" id="start-date">
            <label for="end-date">结束日期:</label>
            <input type="date" id="end-date">
            <button id="generate-btn">生成可视化</button>
        </div>

        <div id="loading-spinner" class="spinner mt-4 hidden"></div>
        <div id="info-container" class="info-box rounded-lg mt-4 hidden">
            <p><strong>正在处理数据...</strong></p>
            <p>已处理开奖期数: <span id="draw-count">0</span> 期</p>
        </div>
        <div id="canvas-container" class="mt-4 rounded-xl hidden"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingSpinner = document.getElementById('loading-spinner');
            const infoContainer = document.getElementById('info-container');
            const drawCountElem = document.getElementById('draw-count');
            const canvasContainer = document.getElementById('canvas-container');
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            const generateBtn = document.getElementById('generate-btn');

            const DATA_URL = "https://data.ny.gov/api/views/5xaw-6ayf/rows.csv?accessType=DOWNLOAD";
            const MAX_NUMBER = 70; // Max number for normalization
            
            let scene, camera, renderer, group;

            const setupScene = () => {
                // Clear any existing scene
                if (scene) {
                    while (scene.children.length > 0) {
                        scene.remove(scene.children[0]);
                    }
                }
                
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                renderer.setClearColor(0x000000, 0);
                // Clear canvas container and add new renderer
                while(canvasContainer.firstChild) {
                    canvasContainer.removeChild(canvasContainer.firstChild);
                }
                canvasContainer.appendChild(renderer.domElement);
                
                const onResize = () => {
                    const width = canvasContainer.clientWidth;
                    const height = canvasContainer.clientHeight;
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                };
                window.addEventListener('resize', onResize, false);
                onResize();
                
                group = new THREE.Group();
                scene.add(group);

                const axesHelper = new THREE.AxesHelper(100);
                group.add(axesHelper);

                const createTextSprite = (text, position) => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 150;
                    canvas.height = 30;
                    context.font = 'Bold 20px Arial';
                    context.fillStyle = 'white';
                    context.fillText(text, 0, 20);
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    const textSprite = new THREE.Sprite(spriteMaterial);
                    textSprite.scale.set(10, 5, 1);
                    textSprite.position.copy(position);
                    return textSprite;
                };
                group.add(createTextSprite('X', new THREE.Vector3(105, 0, 0)));
                group.add(createTextSprite('Y', new THREE.Vector3(0, 105, 0)));
                group.add(createTextSprite('Z', new THREE.Vector3(0, 0, 105)));

                camera.position.z = 100;
                camera.position.y = 50;
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let rotationSpeed = 0.005;

                const onMouseMove = (event) => {
                    if (isDragging) {
                        const deltaX = event.clientX - previousMousePosition.x;
                        const deltaY = event.clientY - previousMousePosition.y;
                        group.rotation.y += deltaX * rotationSpeed;
                        group.rotation.x += deltaY * rotationSpeed;
                    }
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                };
                const onMouseDown = (event) => { isDragging = true; previousMousePosition = { x: event.clientX, y: event.clientY }; };
                const onMouseUp = () => { isDragging = false; };

                canvasContainer.addEventListener('mousedown', onMouseDown);
                canvasContainer.addEventListener('mousemove', onMouseMove);
                canvasContainer.addEventListener('mouseup', onMouseUp);

                const animate = () => {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                };
                animate();
            };

            async function getLotteryDataByDateRange(startDate, endDate) {
                try {
                    console.log(`正在获取从 ${startDate.toISOString().split('T')[0]} 到 ${endDate.toISOString().split('T')[0]} 的数据...`);
                    const response = await fetch(DATA_URL);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const text = await response.text();
                    const lines = text.split('\n').slice(1);
                    
                    const recentDraws = [];
                    for (const line of lines) {
                        if (line.trim() === "") continue;
                        
                        const parts = line.split(',');
                        const drawDateStr = parts[0];
                        const [month, day, year] = drawDateStr.split('/');
                        const drawDate = new Date(`${year}-${month}-${day}`); // Use YYYY-MM-DD for reliable parsing

                        if (drawDate >= startDate && drawDate <= endDate) {
                            const winningNumbersStr = parts[1].split(' ');
                            const allNumbers = winningNumbersStr.map(Number);
                            allNumbers.push(Number(parts[2]));

                            if (allNumbers.length === 6 && !allNumbers.includes(NaN)) {
                                recentDraws.push(allNumbers);
                            } else {
                                console.warn("跳过无效的数据行:", line);
                            }
                        }
                    }
                    return recentDraws;
                } catch (e) {
                    console.error("数据获取或处理失败:", e);
                    return null;
                }
            }

            function calculateEulerCoordinates(numbers) {
                const points = [];
                numbers.sort((a, b) => a - b);
                
                numbers.forEach(num => {
                    const radian = (num / MAX_NUMBER) * (2 * Math.PI);
                    const x = 50 * Math.cos(radian);
                    const y = 50 * Math.sin(radian);
                    const z = num - 35;
                    points.push(new THREE.Vector3(x, y, z));
                });
                return points;
            }

            async function generateVisualization() {
                const startDate = new Date(startDateInput.value);
                const endDate = new Date(endDateInput.value);
                
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime()) || startDate > endDate) {
                    alert('请选择有效的日期范围。');
                    return;
                }
                
                loadingSpinner.classList.remove('hidden');
                infoContainer.classList.add('hidden');
                canvasContainer.classList.add('hidden');

                const recentDraws = await getLotteryDataByDateRange(startDate, endDate);

                loadingSpinner.classList.add('hidden');
                infoContainer.classList.remove('hidden');
                canvasContainer.classList.remove('hidden');

                if (recentDraws && recentDraws.length > 0) {
                    drawCountElem.textContent = recentDraws.length;
                    setupScene();

                    recentDraws.forEach(drawNumbers => {
                        const points = calculateEulerCoordinates(drawNumbers);
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({ color: Math.random() * 0xffffff, transparent: true, opacity: 0.8 });
                        const line = new THREE.Line(geometry, material);
                        group.add(line);

                        points.forEach((point, index) => {
                            const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
                            const sphereMaterial = new THREE.MeshBasicMaterial({ color: material.color });
                            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                            sphere.position.copy(point);
                            group.add(sphere);
                            
                            const textCanvas = document.createElement('canvas');
                            const context = textCanvas.getContext('2d');
                            const text = drawNumbers[index].toString();
                            context.font = 'Bold 30px Arial';
                            const textMetrics = context.measureText(text);
                            textCanvas.width = textMetrics.width + 10;
                            textCanvas.height = 40;
                            context.font = 'Bold 30px Arial';
                            context.fillStyle = 'white';
                            context.fillText(text, 5, 30);
                            
                            const texture = new THREE.CanvasTexture(textCanvas);
                            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                            const textSprite = new THREE.Sprite(spriteMaterial);
                            textSprite.scale.set(15, 7.5, 1);
                            textSprite.position.set(point.x + 10, point.y, point.z);
                            group.add(textSprite);
                        });
                    });
                } else {
                    drawCountElem.textContent = 0;
                    const errorMessage = document.createElement('p');
                    errorMessage.className = "mt-4 text-red-400";
                    errorMessage.textContent = "指定日期范围内没有找到数据。请尝试其他日期。";
                    infoContainer.appendChild(errorMessage);
                }
            }

            generateBtn.addEventListener('click', generateVisualization);

            // Set default date range to last 6 months
            const today = new Date();
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(today.getMonth() - 6);
            startDateInput.value = sixMonthsAgo.toISOString().split('T')[0];
            endDateInput.value = today.toISOString().split('T')[0];
            
            // Initial generation
            generateVisualization();
        });
    </script>
</body>
</html>
